#!KAMAILIO
#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_ASTERISK
#!define WITH_NAT
#!define WITH_IPAUTH

#!define WITH_ACCDB

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!ifndef DBURL
#!define DBURL "mysql://root:root123@172.30.10.122/kamailio"
#!ifdef WITH_ASTERISK
#!define DBASTURL "mysql://root:root123@172.30.10.122/asterisk"
#!endif

#!endif
#!endif
#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5
# debug=3
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

/* number of SIP routing processes for each UDP socket
 * - value inherited by tcp_children and sctp_children when not set explicitely */
children=8

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* number of SIP routing processes for all TCP/TLS sockets */
# tcp_children=8

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
# auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

/* uncomment and configure the following line if you want Kamailio to
 * bind on a specific interface/port/proto (default bind on all available) */
# listen=udp:10.0.0.10:5060
listen=udp:172.30.10.123:5060
listen=udp:10.143.144.98:5060   #advertise 172.30.10.123:5060
 
# listen=udp:172.30.10.123:5060 advertise ims.airtel.in:5060
# advertise=172.30.10.123
 
# listen=udp:172.31.44.42:5060 advertise 13.127.254.72:5060
port=5060

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

/* upper limit for TCP connections (it includes the TLS connections) */
tcp_max_connections=2048

#!ifdef WITH_TLS
enable_tls=yes

/* upper limit for TLS connections */
tls_max_connections=2048
#!endif

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

#!ifdef WITH_PSTN
/* PSTN GW Routing
 *
 * - pstn.gw_ip: valid IP or hostname as string value, example:
 * pstn.gw_ip = "10.0.0.101" desc "My PSTN GW Address"
 *
 * - by default is empty to avoid misrouting */
pstn.gw_ip = "" desc "PSTN GW Address"
pstn.gw_port = "" desc "PSTN GW Port"
#!endif

#!ifdef WITH_VOICEMAIL
/* VoiceMail Routing on offline, busy or no answer
 *
 * - by default Voicemail server IP is empty to avoid misrouting */
voicemail.srv_ip = "" desc "VoiceMail IP Address"
voicemail.srv_port = "5060" desc "VoiceMail Port"
#!endif

#!ifdef WITH_ASTERISK
asterisk.bindip = "192.168.4.39" desc "Asterisk IP Address"
asterisk.bindport = "5060" desc "Asterisk Port"
kamailio.bindip = "192.168.20.210" desc "Kamailio IP Address"
kamailio.bindport = "5060" desc "Kamailio Port"
#!endif



####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "path.so"

modparam("path", "use_received", 1)

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#loadmodule "rtpproxy.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_ASTERISK
loadmodule "uac.so"


modparam("uac", "reg_db_url", "mysql://root:root123@172.30.10.122/kamailio")
#modparam("uac", "uac_reg_table", "uacreg")
modparam("uac", "reg_contact_addr", "10.143.144.98:5060")
modparam("uac", "reg_gc_interval", 10)
modparam("uac", "reg_active", 1)
modparam("uac", "reg_keep_callid", 1)
#modparam("uac", "uac_reg_contact", "sip:+912241817000@10.143.144.98:5060")
#modparam("uac","auth_credentials","689001234:689001234@172.16.152.50")
#modparam("uac","auth_credentials","trunk2_username:trunk2_password@trunk2_domain")




modparam("uac", "reg_retry_interval", 60)  # Retry every 60 seconds if the registration fails
#modparam("uac", "reg_retry_count", 10)     # Retry up to 10 times if registration fails
#modparam("uac", "auth_credentials", 1)     # Use credentials for registration

# Optional: Automatically register on startup
# modparam("uac", "uac_auto_reg", 1)

modparam("uac","auth_username_avp","$avp(user)")
modparam("uac","auth_password_avp","$avp(pass)")
modparam("uac","auth_realm_avp","$avp(realm)")


loadmodule "dispatcher.so"
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "ds_ping_interval", 3)
#modparam("dispatcher", "ds_ping_from", "sip:proxy@192.168.121.211")
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=403;code=404;code=484;code=488;code=481;class=3")
# do failover
modparam("dispatcher", "flags", 2)
#modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
#modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
#modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
#modparam("dispatcher", "force_dst", 1)

modparam("path", "use_received", 1)

#!endif

# ----------------- setting module-specific parameters ---------------

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- sanity params -----
modparam("sanity", "autodrop", 0)

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
# add value to ;lr param to cope with most of the UAs
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
#!ifdef WITH_ASTERISK
modparam("rr", "append_fromtag", 1)
#!else
modparam("rr", "append_fromtag", 0)
#!endif



# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
# modparam("registrar", "max_contacts", 10)
/* max value for expires of registrations */
modparam("registrar", "max_expires", 3600)
/* set it to 1 to enable GRUU */
modparam("registrar", "gruu_enabled", 0)

# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
 * if you enable this parameter, be sure the enable "append_fromtag"
 * in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "load_credentials", "")
 
#!ifdef WITH_ASTERISK
modparam("auth_db", "user_column", "username")
modparam("auth_db", "password_column", "sippasswd")
modparam("auth_db", "db_url", DBASTURL)
modparam("auth_db", "version_table", 0)
#!else
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "use_domain", MULTIDOMAIN)
#!endif



# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif

#!endif


# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
/* register callback to match myself condition with domains list */
modparam("domain", "register_myself", 1)
#!endif

#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif

#!ifdef WITH_NAT
# ----- rtpproxy params -----
# modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
#modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
#modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

loadmodule "rtpengine.so"
modparam("rtpengine", "rtpengine_sock", "udp:localhost:2223")

loadmodule "dialog.so"
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 0)


####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

	route(REQINIT);         #Call REQINIT (Request Initial) route to filter out the worst of the bad traffic and take care of the basics.

	# NAT detection
	route(NATDETECT);
        if (is_method("CANCEL")) {
		rtpengine_delete();
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }
	# handle retransmissions
        if (!is_method("ACK")) {
                if(t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }
	# handle requests within SIP dialogs
        route(WITHINDLG);
	# handle presence related requests
	#route(PRESENCE);
	
	# handle registrations by amit
	route(REGISTRAR);
         
	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}
	# handeling invite method
	if(method=="INVITE")
	{
		record_route();
		if(allow_source_address("200")){        
				#If from a Carrier IP
				xlog("$rm airtel inbound call reviced $si");
				setflag(1);
				route(INBOUNDROUTE);
			}
			else if(allow_source_address("300")){        
				#If from a Asterisk IP
				setflag(2);
				xlog("$rm From asterisk reviced $si");
				route(FROM_DISPATCHER_ROUTE);
			}else
			{
				setflag(3);
				xlog("$rm from Decvice $si");
				route(OPEN_INVITE_ROUTE);
			}
    }
}
route[INBOUNDROUTE]
{
	route(TOASTERISK_DISPATCHER);      #Route the call out to the carrier (to make an external call)
	route(RELAY);                  #Relay traffic to endpoint
	exit();                     #Exit

}

route[TOASTERISK_DISPATCHER]{       #Route to send calls to a Dispatchers at ****
	xlog("sending to tocarrier route from onnetinvite to method $rm");
        #rewritehost("172.30.10.123");    #Rewrite host to be the carrier's IP
	# round robin dispatching on gateways group '1'
	xlog("dispatch call to local Dispatchers/Asterisks by method $rm");
	if(!ds_select_dst("1", "4")) {
		send_reply("404", "No destination");
		exit;
	}
	force_send_socket(udp:172.30.10.123:5060);
	xdbg("--- SCRIPT: going to <$ru> via <$du> (attrs: $xavp(_dsdst_=>attrs))\n");
	t_on_failure("RTF_DISPATCH");
	route(RELAY);
	exit;
}

# 300 route
route[FROM_DISPATCHER_ROUTE]
{
		xlog("Call reciveed under FROM_DISPATCHER_ROUTE  by   $rm");
                
        	#Extract the dialed number (user part of the Request-URI)
        $var(dialed_number) = $rU;  # $rU holds the user part of the URI
 
        	# Check if the dialed number starts with 133
        if ($var(dialed_number) =~ "^133") {
            	xlog("L_INFO", "Call with prefix 133 detected\n");
		 setflag(4); 
            	# Remove the first 3 digits (prefix 133) from the dialed number
            $var(new_dialed_number) = $(var(dialed_number){s.substr,3,0});  # Strip first 3 digits
 
            	# Log the modified dialed number
            	xlog("L_INFO", "Modified dialed number: $var(new_dialed_number)\n");
 
            	# Set the new Request URI for the outbound call (update the user part)
           
           		# $ru = "sip:$var(new_dialed_number)@172.16.152.50";
           		#
           		$avp(from_uri)= "sip:" + $fU + "@ims.airtel.in" ;
			uac_replace_from("","$avp(from_uri)");
             		$ru = "sip:" + $var(new_dialed_number) + "@ims.airtel.in";           
			xlog("L_INFO", "prefix info====: sip:$var(new_dialed_number)@1ims.airtel.in\n");

			$avp(send_call_uri_to) = "sip:"+$var(new_dialed_number)+"@ims.airtel.in"+":5060";
			uac_replace_to("","$avp(send_call_uri_to)");

			#remove_hf("Contact");
			#$var(pai) = "sip:+912241817000@10.143.144.98:5060;alias=172.30.10.121~5060~1";
			#append_hf("Contact: <$var(pai)>\r\n");
#		force_send_socket(udp:10.143.144.98:5060);
#                if(!ds_select_dst("2", "4")) {
#				send_reply("404", "Failed to reach Trunk2 ");
#				exit;
#				}
			force_send_socket(udp:10.143.144.98:5060);
			xdbg("--- SCRIPT: going to <$ru> via <$du> (attrs: $xavp(_dsdst_=>attrs))\n");
			#t_on_failure("RTF_DISPATCH");
			t_on_failure("TRUNK_DISPATCH");
			route(RELAY_TRUNK);
			exit;
 
		}
		else
		{
			xlog("Looking up Location ####### $rm");
			if(!lookup("location"))  
			{	xlog("Location not found ####### $rm");
				sl_send_reply("404", "Sorry User not found");
				exit;
            }
			xlog("Location found and routeing to registerd exten $rm");    
			route(RELAY);                  #Relay traffic to endpoint
			exit();     #Exit
		}
		
}

route[OPEN_INVITE_ROUTE]
{
	xlog("*******IN OPEN INVITE ROUTE***** $rm");
        if (!auth_check("$fd", "sip_buddies", "1")) 

	{ 
		#If credentialas don't match what we have in Subscriber table
				
		xlog("if auth challange error $rm");
		auth_challenge("$fd", "0");          #Send an Auth Challenge
                sl_reply("501", "Who Are You Man!");
		exit;                                #Stop processing
        }
        if (auth_check("$fd", "sip_buddies", "1")) 
        {
		xlog("Location found and routeing to registerd exten $rm");    
				route(TOASTERISK_DISPATCHER);
				exit();     #Exit
        }
        
}


# Wrapper for relaying requests
route[RELAY] {

# - serial forking, RTP relaying handling, a.s.o.
        if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
        }
        if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
        }
        if (is_method("INVITE")) {
                if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
        }

        if (!t_relay()) {
                sl_reply_error();
        }
        exit;
}

route[RELAY_TRUNK] {

# - serial forking, RTP relaying handling, a.s.o.
        if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
        }
        if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
        }
        if (!t_relay()) {
                sl_reply_error();
        }
        exit;
}
# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
        # flood detection from same IP and traffic ban for a while
        # be sure you exclude checking trusted peers, such as pstn gateways
        # - local host excluded (e.g., loop to self)
        if(src_ip!=myself) {
                if($sht(ipban=>$si)!=$null) {
                        # ip is already blocked
                        xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
                        exit;
                }
                if (!pike_check_req()) {
                        xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
                        $sht(ipban=>$si) = 1;
                        exit;
                }
        }
#!endif
        if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
                # silent drop for scanners - uncomment next line if want to reply
                # sl_send_reply("200", "OK");
                exit;
        }

        if (!mf_process_maxfwd_header("10")) {
                sl_send_reply("483","Too Many Hops");
                exit;
        }

        if(is_method("OPTIONS") && uri==myself && $rU==$null) {
                sl_send_reply("200","Keepalive");
                exit;
        }

        if(!sanity_check("1511", "7")) {
                xlog("Malformed SIP message from $si:$sp\n");
                exit;
        }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
        if (!has_totag()) return;

        # sequential request withing a dialog should
        # take the path determined by record-routing
        if (loose_route()) {
                route(DLGURI);
                if (is_method("BYE")) {
			rtpengine_delete();
                       setflag(FLT_ACC); # do accounting ...
                       setflag(FLT_ACCFAILED); # ... even if the transaction fails
                } else if ( is_method("ACK") ) {
                        # ACK is forwarded statelessly
                        route(NATMANAGE);
                } else if ( is_method("NOTIFY") ) {
                        # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
                        record_route();
                }else if(is_method("INVITE")){
			xlog(" WITHIN invite inbound call reviced in ONNETINVITE route >> Now to onnetinvite method ###########################$rm");
                        if(allow_source_address("200"))
                        {
                                #If from a Carrier IP
                                xlog(" WITHIN $rm airtel inbound call reviced $si");
                                setflag(1);
                        }
                        else if(allow_source_address("300"))
                        {
                                #If from a Asterisk IP
                                setflag(2);
                                xlog("WITHIN $rm Asterisk inbound call reviced $si");
                        }
                        else
                        {
                                setflag(3);
                                xlog(" WITHIN $rm Device inbound call reviced $si");
                        }
		}
		
                route(RELAY);
                exit;
        }
	#else{

        if (is_method("SUBSCRIBE") && uri == myself) {
                # in-dialog subscribe requests
                route(PRESENCE);
                exit;
        }
        if ( is_method("ACK") ) {
                if ( t_check_trans() ) {
                        # no loose-route, but stateful ACK;
                        # must be an ACK after a 487
                        # or e.g. 404 from upstream server
                        route(RELAY);
                        exit;
                } else {
                        # ACK without matching transaction ... ignore and discard
                        exit;
                }
        }
        sl_send_reply("404","Not here");
        exit;
	#}
	#exit;
}

# Handle SIP registrations
route[REGISTRAR] {
        if (!is_method("REGISTER|SUBSCRIBE")) return;

        if(isflagset(FLT_NATS)) {
                setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
                # do SIP NAT pinging
                setbflag(FLB_NATSIPPING);
#!endif
        }
        
        xlog("Registration Failed $si:$sp\n");
        if (!save("location")) {
                sl_reply_error();
        }
	add_path_received();
        route(DISPATCH);

        exit;
}

# Forward REGISTER to Asterisk

# Dispatch Registered requests to asterisk
route[DISPATCH] {
	# round robin dispatching on gateways group '1' for registration like media
	if(!ds_select_dst("1", "12")) {
		send_reply("404", "No destination");
		exit;
	}
	xdbg("--- SCRIPT: going to <$ru> via <$du> (attrs: $xavp(_dsdst_=>attrs))\n");
	t_on_failure("RTF_DISPATCH");
	route(RELAY);
	exit;
}

# Try next destionations in failure route
failure_route[RTF_DISPATCH] {
	if (t_is_canceled()) {
		exit;
	}
	# next DST - only for 500 or local timeout
	if (t_check_status("500")
			or (t_branch_timeout() and !t_branch_replied())) 
	{
		if(ds_next_dst()) 
		{
			xdbg("--- SCRIPT: retrying to <$ru> via <$du> (attrs: $xavp(_dsdst_=>attrs))\n");
			t_on_failure("RTF_DISPATCH");
			route(RELAY);
			exit;
		}
		else
		{
		rtpengine_delete();
		}
	}
}

failure_route[TRUNK_DISPATCH] {
	if (t_is_canceled()) {
		exit;
	}
	if(t_check_status("401|407")) {
	xlog("status code is valid auth challenge");
        $avp(user) = "+912241817000";
        $avp(pass) = "Eureka#1";
		$avp(realm) = "ims.airtel.in";
	     uac_auth();
		 route(RELAY_TRUNK);
		 exit;
    }
}

# till here Reg fwd to aster
# User location service
route[LOCATION] {

#!ifdef WITH_SPEEDDIAL
        # search for short dialing - 2-digit extension
        if($rU=~"^[0-9][0-9]$") {
                if(sd_lookup("speed_dial")) {
                        route(SIPOUT);
                }
        }
#!endif

#!ifdef WITH_ALIASDB
        # search in DB-based aliases
        if(alias_db_lookup("dbaliases")) {
                route(SIPOUT);
        }
#!endif

        $avp(oexten) = $rU;
        if (!lookup("location")) {
                $var(rc) = $rc;
                route(TOVOICEMAIL);
                t_newtran();
                switch ($var(rc)) {
                        case -1:
                        case -3:
                                send_reply("404", "Not Found");
                                exit;
                        case -2:
                                send_reply("405", "Method Not Allowed");
                                exit;
                }
        }

        # when routing via usrloc, log the missed calls also
        if (is_method("INVITE")) {
                setflag(FLT_ACCMISSED);
        }

        route(RELAY);
        exit;
}

# Presence server processing
route[PRESENCE] {
        if(!is_method("PUBLISH|SUBSCRIBE")) return;

        if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
                route(TOVOICEMAIL);
                # returns here if no voicemail server is configured
                sl_send_reply("404", "No voicemail service");
                exit;
        }

#!ifdef WITH_PRESENCE
        if (!t_newtran()) {
                sl_reply_error();
                exit;
        }

        if(is_method("PUBLISH")) {
                handle_publish();
                t_release();
        } else if(is_method("SUBSCRIBE")) {
                handle_subscribe();
                t_release();
        }
        exit;
#!endif

        # if presence enabled, this part will not be executed
        if (is_method("PUBLISH") || $rU==$null) {
                sl_send_reply("404", "Not here");
                exit;
        }
        return;
}

# IP authorization and user authentication
route[AUTH] {
#!ifdef WITH_AUTH
#!ifdef WITH_IPAUTH
        if((!is_method("REGISTER")) && allow_source_address()) {
                # source IP allowed
                return;
        }
if (is_method("REGISTER") || from_uri==myself){
if (!allow_trusted()) {
      xlog('wokred here  for ipauth check');
	sl_send_reply("403", "Forbidden");
}
}

#!endif
 
	if (is_method("REGISTER") || from_uri==myself)
	{
		# authenticate requests

#!ifdef WITH_ASTERISK

		if (!auth_check("$fd", "sip_buddies", "1")) {
#!else
		if (!auth_check("$fd", "subscriber", "1")) {
#!endif
			auth_challenge("$fd", "0");
			exit;
		}
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();
	}
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
	if (from_uri!=myself && uri!=myself)
	{
		sl_send_reply("403","Not relaying");
		exit;
	}
 
#!endif
	return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
        force_rport();
        if (nat_uac_test("19")) {
                if (is_method("REGISTER")) {
                        fix_nated_register();
                } else {
                        if(is_first_hop()) {
                                set_contact_alias();
                        }
                }
                setflag(FLT_NATS);
        }
#!endif
        return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_NAT
        if (is_request()) {
                if(has_totag()) {
                        if(check_route_param("nat=yes")) {
                                setbflag(FLB_NATB);
                        }
                }
        }
        if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

        if (is_request()) {
                if (!has_totag()) {
                        if(t_is_branch_route()) {
                                add_rr_param(";nat=yes");
                        }
                }
        }
        if (is_reply()) {
                if(isbflagset(FLB_NATB)) {
                        if(is_first_hop())
                                set_contact_alias();
                }
        }

	if(isbflagset(FLB_NATB)) {
		# no connect message in a dialog involving NAT traversal
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}

#!endif
        return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
        if(!isdsturiset()) {
                handle_ruri_alias();
        }
#!endif
        return;
}

# Routing to foreign domains
route[SIPOUT] {
        if (uri==myself) return;

        append_hf("P-hint: outbound\r\n");
        route(RELAY);
        exit;
}

# PSTN GW routing
route[PSTN] {
#!ifdef WITH_PSTN
        # check if PSTN GW IP is defined
        if (strempty($sel(cfg_get.pstn.gw_ip))) {
                xlog("SCRIPT: PSTN routing enabled but pstn.gw_ip not defined\n");
                return;
        }

        # route to PSTN dialed numbers starting with '+' or '00'
        #     (international format)
        # - update the condition to match your dialing rules for PSTN routing
        if(!($rU=~"^(\+|00)[1-9][0-9]{3,20}$")) return;

        # only local users allowed to call
        if(from_uri!=myself) {
                sl_send_reply("403", "Not Allowed");
                exit;
        }

        if (strempty($sel(cfg_get.pstn.gw_port))) {
                $ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
        } else {
                $ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
                                        + $sel(cfg_get.pstn.gw_port);
        }

        route(RELAY);
        exit;
#!endif

        return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
        # allow XMLRPC from localhost
        if ((method=="POST" || method=="GET")
                        && (src_ip==127.0.0.1)) {
                # close connection only for xmlrpclib user agents (there is a bug in
                # xmlrpclib: it waits for EOF before interpreting the response).
                if ($hdr(User-Agent) =~ "xmlrpclib")
                        set_reply_close();
                set_reply_no_connect();
                dispatch_rpc();
                exit;
        }
        send_reply("403", "Forbidden");
        exit;
}
#!endif

# Routing to voicemail server
route[TOVOICEMAIL] {
#!ifdef WITH_VOICEMAIL
        if(!is_method("INVITE|SUBSCRIBE")) return;

        # check if VoiceMail server IP is defined
        if (strempty($sel(cfg_get.voicemail.srv_ip))) {
                xlog("SCRIPT: VoiceMail routing enabled but IP not defined\n");
                return;
        }
        if(is_method("INVITE")) {
                if($avp(oexten)==$null) return;

                $ru = "sip:" + $avp(oexten) + "@" + $sel(cfg_get.voicemail.srv_ip)
                                + ":" + $sel(cfg_get.voicemail.srv_port);
        } else {
                if($rU==$null) return;

                $ru = "sip:" + $rU + "@" + $sel(cfg_get.voicemail.srv_ip)
                                + ":" + $sel(cfg_get.voicemail.srv_port);
        }
        route(RELAY);
        exit;
#!endif

        return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
        xdbg("new branch [$T_branch_idx] to $ru\n");
		if(isflagset(1))
		{
		 xlog("SCRIPT: 111111111111111 call from Airtel MANAGE_BRANCH\n");
		 rtpengine_offer("RTP/AVP replace-session-connection replace-origin direction=internal direction=external");
		}
		if(isflagset(2))
                {
			if(isflagset(4))
			{
			xlog("SCRIPT: 222222222222222222 call from Asterisk MANAGE_BRANCH\n");
	                #rtpengine_offer("RTP/AVP replace-session-connection replace-origin direction=internal direction=internal");
			rtpengine_offer("RTP/AVP replace-session-connection replace-origin direction=external direction=internal");
			}
			else{
	                xlog("SCRIPT: 33333333333333333 call from Airtel MANAGE_BRANCH\n");
        	        rtpengine_offer("RTP/AVP replace-session-connection replace-origin direction=external direction=external");
			}
                }

		if(isflagset(3))
		{
		xlog("SCRIPT: 44444444444444444444 call from Asterisk MANAGE_BRANCH\n");
		rtpengine_offer("RTP/AVP replace-session-connection replace-origin direction=external direction=external");

		}
        route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
        xdbg("incoming reply\n");
		if(allow_source_address("300") && status=~"200|183")
			{
				if(isflagset(1))
				{
				xlog("SCRIPT: $si 200 coming Asterisk to carrier \n");
				rtpengine_answer("RTP/AVP replace-session-connection replace-origin direction=external direction=internal");
				}
				else{
				xlog("SCRIPT: $si 200 coming from Asterisk to User \n");
				rtpengine_answer("RTP/AVP replace-session-connection replace-origin direction=external direction=external");
				}
			}

		if(!allow_source_address("300") && status=~"200|183")
			{
				if(isflagset(4))
				{
				xlog("SCRIPT: ----------------- $si 200 coming carrier \n");
				rtpengine_answer("RTP/AVP replace-session-connection replace-origin direction=internal direction=external");
				}
				else{
				xlog("SCRIPT: ---------------- $si 200 coming device \n");
				xlog("SCRIPT: $si MANAGE_REPLY\n");
				rtpengine_answer("RTP/AVP replace-session-connection replace-origin direction=external direction=external");
				}
			}
			
        if(status=~"[12][0-9][0-9]") {
                route(NATMANAGE);
			}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
        route(NATMANAGE);
        if (t_is_canceled()) exit;

#!ifdef WITH_BLOCK3XX
        # block call redirect based on 3xx replies.
        if (t_check_status("3[0-9][0-9]")) {
                t_reply("404","Not found");
                exit;
        }
#!endif
	if (!t_check_status("401|407")) {
	rtpengine_delete();
	}

#!ifdef WITH_BLOCK401407
        # block call redirect based on 401, 407 replies.
        if (t_check_status("401|407|400")) {
                t_reply("404","Not found");
                exit;
        }
#!endif

#!ifdef WITH_VOICEMAIL
        # serial forking
        # - route to voicemail on busy or no answer (timeout)
        if (t_check_status("486|408")) {
                $du = $null;
                route(TOVOICEMAIL);
                exit;
        }
#!endif
}
